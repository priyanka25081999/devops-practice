1. Ownerships: Owned by replicasets, owned by deployments etc. we have a owner references field in the yaml file.
2. Controllers is a loop which continuolsy check with api server to see if there is any request of CRUD and it also checks the desired state of the application it compares it.
3. if you need whole history that is called edge triggered and if you don't need the whole history then that is called the level triggered.
4. Job of a scheduler is to place a pod in of the containers.
5. Predicates are hard constraints, they are the things which cannot be violated. Predicates allow controllers to filter events before they are provided to EventHandlers. Filtering is useful because your controller may only want to handle specific types of events. Filtering also helps reduce chattiness with the API server, as Reconcile() is only called for events transformed by EventHandlers. Link - https://sdk.operatorframework.io/docs/building-operators/golang/references/event-filtering/#:~:text=Predicates%20allow%20controllers%20to%20filter,for%20events%20transformed%20by%20EventHandlers.
6. Informers use the Kubernetes API to learn about changes in the state of a Kubernetes cluster and use that information to maintain a cache (the indexer) of the current cluster state and to inform clients about the changes by calling handler functions. To achieve this, an informer (more specifically: a shared informer) is again a composition of several components.
7. Finalizers - https://kubernetes.io/docs/concepts/overview/working-with-objects/finalizers/#:~:text=Finalizers%20are%20namespaced%20keys%20that,resources%20the%20deleted%20object%20owned.
https://www.middlewareinventory.com/blog/kubectl-delete-stuck-what-to-do/#:~:text=What%20to%20do%20when%20your%20kubectl%20delete%20stuck&text=The%20preceding%20command%20is%20to,delete%20and%20which%20is%20stuck.
To remove the finalizer metadata and delete the resource - kubectl patch ingress nameofingress -p '{"metadata":{"finalizers":[]}}' â€“ type=merge
